using JuMP, Gurobi

function find_regular_graph()
    # Créer le modèle avec Gurobi comme solveur
    model = Model(Gurobi.Optimizer)

    # Paramètres
    N = 36
    group_size = 9
    groupes = [1:9, 10:18, 19:27, 28:36]
    nb_color = 9


    # Variables
    @variable(model, x[1:N, 1:N, 1:nb_color], Bin)

    # Contraintes d'unicité de couleur pour les arêtes partant d'un même sommet
    for i in 1:N
        for c in 1:nb_color
            @constraint(model, sum(x[i, j, c] for j in 1:N if j != i) <= 1)
        end
    end

    # On ne peut pas colorier une arête avec deux couleurs différentes
    for i in 1:N, j in 1:N
        if i != j
            @constraint(model, sum(x[i, j, c] for c in 1:nb_color) <= 1)
        end
    end

    # Deux arêtes par sommet dans chaque groupe
    for i in 1:N
        for group in groupes
            @constraint(model, sum(x[i, j, c] for j in group for c in 1:nb_color if i != j) == 2)
        end
    end


    # Éviter les boucles et assurer la symétrie des arêtes
    for i in 1:N, c in 1:nb_color
        @constraint(model, x[i, i, c] == 0)
        for j in 1:N
            @constraint(model, x[i, j, c] == x[j, i, c])
        end
    end


    # Contrainte pour le graphe

    for k in 1:3:7
        #Contrainte A, B
        @constraint(model, sum(x[k, k+9 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k, k+10, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+1, k+10, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+1, k+11, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+2, k+9, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+2, k+11, c] for c in 1:nb_color)==1)
        # Contrainte A, C
        @constraint(model, sum(x[k, k+18 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k, k+19, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+1, k+19, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+1, k+20, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+2, k+18, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+2, k+20, c] for c in 1:nb_color)==1)
        # Contrainte A, D
        @constraint(model, sum(x[k, k+27 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k, k+28, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+1, k+28, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+1, k+29, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+2, k+27, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+2, k+29, c] for c in 1:nb_color)==1)
        # Contrainte B, C
        @constraint(model, sum(x[k+9, k+18 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+9, k+19, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+10, k+19, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+10, k+20, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+11, k+18, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+11, k+20, c] for c in 1:nb_color)==1)
        # Contrainte B, D
        @constraint(model, sum(x[k+9, k+27 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+9, k+28, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+10, k+28, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+10, k+29, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+11, k+27, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+11, k+29, c] for c in 1:nb_color)==1)
        # Contrainte C, D
        @constraint(model, sum(x[k+18, k+27 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+18, k+28, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+19, k+28, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+19, k+29, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+20, k+27, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[k+20, k+29, c] for c in 1:nb_color)==1)

        #Contrainte A,A
        @constraint(model, sum(x[1, 2 , c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[2, 3, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[3, 4, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[1, 4, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[5, 6, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[6, 7, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[7, 8, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[8, 9, c] for c in 1:nb_color)==1)
        @constraint(model, sum(x[5, 9, c] for c in 1:nb_color)==1)

        for starting_group in 9:9:27
            #Contrainte B,B / C,C et D,D
            @constraint(model, sum(x[k + starting_group, k+1 + starting_group, c] for c in 1:nb_color)>=1)
            @constraint(model, sum(x[k+1 + starting_group, k+2 + starting_group, c] for c in 1:nb_color)>=1)
            @constraint(model, sum(x[k + starting_group, k+2 + starting_group, c] for c in 1:nb_color)>=1)
        end
    end
           




        

    








#------------------------------SOLVEUR-------------------------------------------------------



    # Résolution du modèle
    optimize!(model)
    if termination_status(model) == MOI.OPTIMAL
        println("Une solution existe.")
        aretes = []
        for i in 1:N
            for j in i+1:N
                for c in 1:nb_color
                    if value(x[i, j, c]) > 0.5
                        push!(aretes, (i, j, c))
                    end
                end
            end
        end
        println("Arêtes du graphe trouvé :")
        println(aretes)
    else
        println("Aucune solution trouvée.")
    end
end

find_regular_graph()
